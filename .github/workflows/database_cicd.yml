name: Database CI/CD

on:
  workflow_call:
    inputs:
      package_name:
        required: true
        type: string
        description: The name of the package to release
    secrets:
      GH_PAT:
        required: true
        description: GitHub Personal Access Token with repo and write:packages scopes

jobs:
  # release-dev:
  #   if: github.ref == 'refs/heads/main'
  #   runs-on: ubuntu-latest
  #   environment: Dev
  #   steps:
  #     # Checkout repository à la bonne branche/tag
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     # Connexion à GHCR
  #     - name: Log in to GitHub Container Registry
  #       run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin
  #       shell: bash

  #     # Build Docker image avec SHA ou version
  #     - name: Build Docker image (sha)
  #       run: |
  #         TAG=${GITHUB_SHA}
  #         docker build -t ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:dev-$TAG .
  #       shell: bash

  #     # Build Docker image latest pour l'environnement
  #     - name: Build Docker image (latest)
  #       run: |
  #         docker build -t ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:dev-latest .
  #       shell: bash

  #     # Push Docker image avec SHA
  #     - name: Push Docker image (sha)
  #       run: |
  #         TAG=${GITHUB_SHA}
  #         docker push ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:dev-$TAG
  #       shell: bash

  #     # Push Docker image latest
  #     - name: Push Docker image (latest)
  #       run: |
  #         docker push ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:dev-latest
  #       shell: bash

  # publish-dev:
  #   if: github.ref == 'refs/heads/main'
  #   needs: release-dev
  #   runs-on: ubuntu-latest
  #   environment: Dev
  #   steps:
  #     - name: Notify Dev Deployment
  #       run: echo "Dev deployment for ${{ inputs.package_name }} has been published."

  # release-staging:
  #   runs-on: ubuntu-latest
  #   needs: publish-dev
  #   environment: Staging
  #   steps:
  #     # Checkout repository à la bonne branche/tag
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     # Connexion à GHCR
  #     - name: Log in to GitHub Container Registry
  #       run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin
  #       shell: bash

  #     # Build Docker image avec SHA ou version
  #     - name: Build Docker image (sha)
  #       run: |
  #         TAG=${GITHUB_SHA}
  #         docker build -t ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:staging-$TAG .
  #       shell: bash

  #     # Build Docker image latest pour l'environnement
  #     - name: Build Docker image (latest)
  #       run: |
  #         docker build -t ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:staging-latest .
  #       shell: bash

  #     # Push Docker image avec SHA
  #     - name: Push Docker image (sha)
  #       run: |
  #         TAG=${GITHUB_SHA}
  #         docker push ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:staging-$TAG
  #       shell: bash

  #     # Push Docker image latest
  #     - name: Push Docker image (latest)
  #       run: |
  #         docker push ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:staging-latest
  #       shell: bash

  # publish-staging:
  #   needs: release-staging
  #   runs-on: ubuntu-latest
  #   environment: Staging
  #   steps:
  #     - name: Notify Staging Deployment
  #       run: echo "Staging deployment for ${{ inputs.package_name }} has been published."

  release-prod:
    runs-on: ubuntu-latest
    # needs: publish-staging
    # environment: Production
    steps:
      # Checkout repository à la bonne branche/tag
      - name: Checkout repository
        uses: actions/checkout@v4

      # Connexion à GHCR
      - name: Log in to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin
        shell: bash

      - name: Get latest release tag
        id: lasttag
        shell: bash
        run: |
          set -e

          # Récupérer le dernier tag de release via GitHub CLI
          LAST_TAG=$(gh release view --json tagName -q '.tagName' 2>/dev/null || echo "0.0.0")

          # Si aucun tag trouvé => fallback 0.0.0
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="0.0.0"
          fi

          echo "Last release tag found: $LAST_TAG"
          echo "LAST_TAG=$LAST_TAG" >> $GITHUB_ENV

      - name: Increment tag based on commit message
        shell: bash
        run: |
          COMMIT_MSG="$(git log -1 --pretty=%B)"
          echo "Commit message: $COMMIT_MSG"

          # Extraire major, minor, patch
          IFS='.' read -r MAJOR MINOR PATCH <<< "${LAST_TAG}"

          if [[ "$COMMIT_MSG" =~ ^fix: ]]; then
            PATCH=$((PATCH + 1))
          elif [[ "$COMMIT_MSG" =~ ^feat: ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [[ "$COMMIT_MSG" =~ ^major: ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          else
            echo "::error::Commit message must start with 'fix:', 'feat:' or 'major:'"
            exit 1
          fi

          NEW_TAG="$MAJOR.$MINOR.$PATCH"
          echo "New tag generated: $NEW_TAG"
          echo "TAG=$NEW_TAG" >> $GITHUB_ENV

      - name: Build Docker image (versioned)
        run: |
          echo "Building Docker image with tag: prod-$TAG"
          docker build -t ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:$TAG .
        shell: bash

      - name: Build Docker image (latest)
        run: |
          echo "Building Docker image with tag: latest"
          docker build -t ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:latest .
        shell: bash

      - name: Create GitHub release with tag
        id: create_release
        run: |
          # Créer la release sur GitHub avec le tag
          zip -r liquibase.zip ./liquibase
          gh release create $TAG liquibase.zip --title "Release $TAG" --notes "Release version $TAG" --draft
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Set output TAG
        run: echo "TAG=$NEW_TAG" >> $GITHUB_OUTPUT

  publish-prod:
    runs-on: ubuntu-latest
    needs: release-prod
    steps:
      # Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # Connexion à GHCR
      - name: Log in to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin
        shell: bash

      # Récupérer le tag généré dans release-prod
      - name: Set TAG from previous job
        run: echo "TAG=${{ needs.release-prod.outputs.TAG }}" >> $GITHUB_ENV

      # Push Docker image versionnée
      - name: Push Docker image (versioned)
        run: |
          echo "Pushing Docker image with tag: $TAG"
          docker push ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:$TAG
        shell: bash

      # Push Docker image latest
      - name: Push Docker image (latest)
        run: |
          echo "Pushing Docker image with tag: latest"
          docker push ghcr.io/${GITHUB_REPOSITORY_OWNER}/${{ inputs.package_name }}:latest
        shell: bash

      # Ajouter un tag Git sur le commit actuel
      - name: Tag the commit
        run: |
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git tag $TAG
          git push origin $TAG
        shell: bash

      # Publier la release sur GitHub
      - name: Create GitHub release with tag
        run: |
          zip -r liquibase.zip ./liquibase
          gh release create $TAG liquibase.zip --title "Release $TAG" --notes "Release version $TAG" --draft
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
