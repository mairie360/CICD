name: BFF Generic CICD

on:
  workflow_call:
    inputs:
      package_name:
        required: true
        type: string
        description: "Nom de l'image Docker et du package"
      node_version:
        required: false
        type: number
        default: 20
        description: "Version de Node.js"

jobs:
  # --- PARTIE CI (NODE.TS) ---
  dependencies:
    name: Install dependencies
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: 'npm'
      - run: npm ci
      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}

  lint:
    name: Lint code
    runs-on: ubuntu-latest
    needs: dependencies
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
      - name: Restore node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      - run: npm run lint

  build:
    name: Build Check (TS)
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
      - name: Restore node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      - run: npm run build

  test:
    name: Test Check (TS)
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
      - name: Restore node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      - run: npm test
        
# -- TODO: add integration tests

  # --- PARTIE CD (DOCKER & RELEASES) ---
  
  release-dev:
    if: github.ref == 'refs/heads/main'
    needs: test
    runs-on: ubuntu-latest
    environment: Dev
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin

      - name: Build & Push Images (Dev)
        run: |
          SHA_TAG=${GITHUB_SHA::7}
          # Conversion en minuscule pour le registre docker
          OWNER_LOWER="${GITHUB_REPOSITORY_OWNER,,}"
          REPO="ghcr.io/$OWNER_LOWER"

          docker build -t $REPO/${{ inputs.package_name }}:dev-$SHA_TAG -t $REPO/${{ inputs.package_name }}:dev-latest .
          docker push $REPO/${{ inputs.package_name }} --all-tags

  release-staging:
    needs: release-dev
    runs-on: ubuntu-latest
    environment: Staging
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin

      - name: Build & Push Images (Staging)
        run: |
          SHA_TAG=${GITHUB_SHA::7}
          OWNER_LOWER="${GITHUB_REPOSITORY_OWNER,,}"
          REPO="ghcr.io/$OWNER_LOWER"

          docker build -t $REPO/${{ inputs.package_name }}:staging-$SHA_TAG -t $REPO/${{ inputs.package_name }}:staging-latest .
          docker push $REPO/${{ inputs.package_name }} --all-tags

  release-prod:
    needs: release-staging
    runs-on: ubuntu-latest
    environment: Prod
    permissions:
      contents: write
      packages: write
    outputs:
      TAG: ${{ steps.set_tag.outputs.TAG }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin

      - name: Calculate Next Version
        id: set_tag
        shell: bash
        run: |
          # Récupération du dernier tag ou défaut 0.0.0
          LAST_TAG=$(gh release view --json tagName -q '.tagName' 2>/dev/null || echo "0.0.0")
          COMMIT_MSG="$(git log -1 --pretty=%B)"
          # Nettoyage du 'v' si présent
          IFS='.' read -r MAJOR MINOR PATCH <<< "${LAST_TAG//v/}"

          # Logique de versioning sémantique basée sur le message de commit
          if [[ "$COMMIT_MSG" =~ ^fix: ]]; then PATCH=$((PATCH + 1))
          elif [[ "$COMMIT_MSG" =~ ^feat: ]]; then MINOR=$((MINOR + 1)); PATCH=0
          elif [[ "$COMMIT_MSG" =~ ^major: ]]; then MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0
          else 
            echo "Format de message de commit invalide pour une release (attendu: fix:, feat:, major:)"; 
            exit 1; 
          fi

          echo "TAG=$MAJOR.$MINOR.$PATCH" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build & Push Images (Prod)
        run: |
          OWNER_LOWER="${GITHUB_REPOSITORY_OWNER,,}"
          REPO="ghcr.io/$OWNER_LOWER"
          TAG=${{ steps.set_tag.outputs.TAG }}

          docker build -t $REPO/${{ inputs.package_name }}:$TAG -t $REPO/${{ inputs.package_name }}:latest .
          docker push $REPO/${{ inputs.package_name }} --all-tags

      - name: Create GitHub Release
        run: |
          TAG=${{ steps.set_tag.outputs.TAG }}
          
          # On crée une archive des sources pour la forme, ou des fichiers de config spécifiques
          zip -r release_assets_v${TAG}.zip README.md Dockerfile package.json

          gh release create "v${TAG}" release_assets_v${TAG}.zip \
            --title "Release v${TAG}" \
            --notes "### Version v${TAG} (BFF)
            Automated release based on commit message.
            Docker Image: ghcr.io/${GITHUB_REPOSITORY_OWNER,,}/${{ inputs.package_name }}:$TAG"
        env:
          GH_TOKEN: ${{ github.token }}